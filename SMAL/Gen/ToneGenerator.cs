/*
 * MIT License (MIT) - Copyright (c) 2020 SMAL Authors
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at <https://opensource.org/licenses/MIT>.
 */
using System;

namespace SMAL.Gen
{
	/// <summary>
	/// Generates an infinite source of pure-tone samples at a given frequency and amplitude.
	/// </summary>
	public sealed class ToneGenerator : ISampleSource
	{
		private const float TWO_PI = MathF.PI * 2f;

		#region Fields
		/// <summary>
		/// The generated channel set. Always <see cref="AudioChannels.Mono"/> for <see cref="ToneGenerator"/>.
		/// </summary>
		public AudioChannels Channels => AudioChannels.Mono;

		/// <summary>
		/// The audio sampling rate of the generator instance.
		/// </summary>
		public uint SampleRate { get; }

		/// <summary>
		/// The tone features generated by the generator instance.
		/// </summary>
		public Tone Tone { get; }

		// Phase offset for the generated samples - keeps track of current location in waveform generation
		private float _offset;
		#endregion // Fields

		/// <summary>
		/// Describes a new generator for the given tone at the given sampling rate.
		/// </summary>
		/// <param name="tone">The tone to generate.</param>
		/// <param name="rate">The sampling rate at which to generate the tone.</param>
		public ToneGenerator(in Tone tone, uint rate)
		{
			Tone = tone;
			SampleRate = rate;
			_offset = 0;
		}

		/// <summary>
		/// Describes a new generator for the given tone features and sampling rate.
		/// </summary>
		/// <param name="freq">The tone frequency.</param>
		/// <param name="form">The tone waveform.</param>
		/// <param name="rate">The sampling rate at which to generate the tone.</param>
		public ToneGenerator(float freq, Waveform form, uint rate) :
			this(new Tone(freq, form), rate)
		{ }

		/// <summary>
		/// Resets the generator state to when it was constructed (restarts the sample sequence for the tone).
		/// </summary>
		public void Reset() => _offset = 0;

		/// <inheritdoc/>
		public uint GetSamples(Span<short> buffer)
		{
			Generate(Tone, SampleRate, _offset, buffer);
			_offset += (buffer.Length / (float)SampleRate);
			return (uint)buffer.Length;
		}

		/// <inheritdoc/>
		public uint GetSamples(Span<float> buffer)
		{
			Generate(Tone, SampleRate, _offset, buffer);
			_offset += (buffer.Length / (float)SampleRate);
			return (uint)buffer.Length;
		}

		/// <summary>
		/// Generate tone samples into the buffer.
		/// </summary>
		/// <param name="tone">The tone to generate data for.</param>
		/// <param name="rate">The sample rate of the generated data.</param>
		/// <param name="startTime">The start time (in seconds) for the tone generation.</param>
		/// <param name="buffer">The buffer to generate samples into.</param>
		public static void Generate(in Tone tone, float rate, float startTime, Span<short> buffer)
		{
			Span<float> samples = stackalloc float[128];

			int done = 0;
			while (done < buffer.Length)
			{
				int curr = Math.Min(buffer.Length - done, 128);
				Generate(tone, rate, startTime + (done / rate), samples.Slice(0, curr));
				SampleUtils.Convert(samples.Slice(0, curr), buffer.Slice(done, curr));
				done += curr;
			}
		}

		/// <summary>
		/// Generate tone samples into the buffer.
		/// </summary>
		/// <param name="tone">The tone to generate data for.</param>
		/// <param name="rate">The sample rate of the generated data.</param>
		/// <param name="startTime">The start time (in seconds) for the tone generation.</param>
		/// <param name="buffer">The buffer to generate samples into.</param>
		public static void Generate(in Tone tone, float rate, float startTime, Span<float> buffer)
		{
			int done = 0;
			float step = 1f / rate;
			float amp = tone.Amplitude;
			int widx = 0;
			float offset = startTime;

			if (tone.Waveform == Waveform.Sine)
			{
				float W = TWO_PI * tone.Frequency;

				while ((done++) < buffer.Length)
				{
					buffer[widx++] = amp * MathF.Sin(W * offset);
					offset += step;
				}
			}
			else if (tone.Waveform == Waveform.Square)
			{
				float f2 = tone.Frequency * 2;

				while ((done++) < buffer.Length)
				{
					float scale = offset * f2;
					bool odd = ((long)scale & 1) == 1;
					buffer[widx++] = odd ? -amp : amp;
					offset += step;
				}
			}
			else if (tone.Waveform == Waveform.Triangular)
			{
				float f2 = tone.Frequency * 2;

				while ((done++) < buffer.Length)
				{
					float scale = offset * f2;
					float modoff = scale - (long)scale;
					float samp = modoff * 2;
					bool odd = ((ulong)scale & 1) == 1;
					buffer[widx++] = ((odd ? (2 - samp) : samp) - 1) * amp;
					offset += step;
				}
			}
			else
			{
				while ((done++) < buffer.Length)
				{
					float scale = offset * tone.Frequency;
					float modoff = scale - (long)scale;
					buffer[widx++] = ((modoff * 2) - 1) * amp;
					offset += step;
				}
			}
		}
	}
}
